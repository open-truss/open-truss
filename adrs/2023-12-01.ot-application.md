# Title: Open Truss application

**Status**: Research in progress

**Date**: 2023-12-01

# Context

Open Truss is designed to be powerful framework for building internal tools. Thus far our discussion has been focused on the front-end. After spending some time building the rendering engine, designing the unified query engine, and discussing workflow implementation, it became clear Open Truss will need a significant server-side component to make the system work. In service of enabling this, this ADR explores how we can design Open Truss to support these features.

## Use cases that may need server-side component.

- **Query Engines** - OT queries multiple backends (e.g. mysql, REST).
- **Stored Queries** - Running slow or large result-set queries and storing the results.
- **Workflows / Queues** - Some tools are multi-step workflows, require operating on multiple results, or need automation applied to them.
- **Rule engine / map reduce** - Some tools query for data, apply a transformation, and submit the results.
- **Configuration system** - OT will be entirely yaml configurable. These need to be stored somewhere and APIs exposed to operate on the configurations.

## Acceptance Criteria

However we decide to transform OT it should have the following properties:

- **Installation for applications should continue to be reasonably simple**
- **OT should continue to be general enough to be installed by most node apps**
- **Developing OT features that require APIs, database integrations, and React pages should be easy**

## System Architecture 1: Full-stack OT package

OT has libraries to optionally make it a full-stack React app with APIs. OT exposes an installable middleware that can be mounted on an application's router. For new apps this can be mapped to `/` for existing it could be `/ot`. All requests sent to that route are resolved by OT. OT can serve react pages, respond to API calls, query databases, etc. This gives us control over the full stack and allows us to implement server and client-side features.

[System diagram]

### System Details

Consider this a possible future state. Not every piece has to be done immediately.

- **Routing** - OT's client and server-side have full control over routing like a stand-alone app (because it is). In the case where OT is embedded in another app, this does mean that the experience hopping between apps will be disjointed. When starting fresh on a new app, OT can be the entire app.
- **Initialization file** - OT exposes an initialization file that the application can use to configure OT.
- **Configuration system** - OT will have a configuration system that can be used to configure the app. e.g. pages, backends, 
- **Database migrations** - OT provides database migrations that the application should run to setup OT tables.
- **Authentication** - On the server because OT is middleware, Identity / Authn / Authz can be delegated to an upper layer of middleware. On the client, OT pages can be wrapped with OT / app components that handle authentication.
- **Next.js RSC** - Because OT is essentially a stand-alone app in theory we can embed a full-class app and leverage technologies like next.js and RSC.
- **Middleware interface** - There are multiple node routers with different interfaces e.g. `(req, res) => {}`, `(ctx) => {}`. OT can have a shim layer to match these interfaces, coerce the values to a uniform shape, and pass them to the OT code.

